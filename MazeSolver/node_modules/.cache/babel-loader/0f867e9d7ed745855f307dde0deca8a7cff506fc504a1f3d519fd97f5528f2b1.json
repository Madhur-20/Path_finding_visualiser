{"ast":null,"code":"export function depthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\nexport function getOptPathNodes_DFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["depthFirstSearch","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","push","length","closestNode","shift","isWall","isVisited","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","unshift","node","neighbours","row","col","filter","neighbour","getOptPathNodes_DFS","nodesInShortestPathOrder","currentNode"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/search_algorithms/depthFirstSearch.js"],"sourcesContent":["export function depthFirstSearch(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let unvisitedNodes = [];\r\n    let visitedNodesInOrder = [];\r\n\r\n    unvisitedNodes.push(startNode);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        visitedNodesInOrder.push(closestNode);\r\n        closestNode.isVisited = true;\r\n\r\n        let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\r\n        for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n            unvisitedNeighbour.previousNode = closestNode;\r\n            unvisitedNodes.unshift(unvisitedNeighbour);\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n\r\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n\r\n}\r\n\r\nexport function getOptPathNodes_DFS(finishNode) {\r\n\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPathOrder;\r\n\r\n}"],"mappings":"AAAA,OAAO,SAASA,gBAAgBA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAE1D,IAAI,CAACD,SAAS,IAAI,CAACC,UAAU,IAAID,SAAS,KAAKC,UAAU,EAAE,OAAO,KAAK;EAEvE,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIC,mBAAmB,GAAG,EAAE;EAE5BD,cAAc,CAACE,IAAI,CAACJ,SAAS,CAAC;EAE9B,OAAOE,cAAc,CAACG,MAAM,KAAK,CAAC,EAAE;IAEhC,IAAIC,WAAW,GAAGJ,cAAc,CAACK,KAAK,CAAC,CAAC;IAExC,IAAID,WAAW,CAACE,MAAM,EAAE;IACxB,IAAIF,WAAW,KAAKL,UAAU,EAAE,OAAOE,mBAAmB;IAE1DA,mBAAmB,CAACC,IAAI,CAACE,WAAW,CAAC;IACrCA,WAAW,CAACG,SAAS,GAAG,IAAI;IAE5B,IAAIC,mBAAmB,GAAGC,sBAAsB,CAACL,WAAW,EAAEP,IAAI,CAAC;IACnE,KAAK,IAAIa,kBAAkB,IAAIF,mBAAmB,EAAE;MAChDE,kBAAkB,CAACC,YAAY,GAAGP,WAAW;MAC7CJ,cAAc,CAACY,OAAO,CAACF,kBAAkB,CAAC;IAC9C;EAEJ;EAEA,OAAOT,mBAAmB;AAE9B;AAEA,SAASQ,sBAAsBA,CAACI,IAAI,EAAEhB,IAAI,EAAE;EAExC,IAAIiB,UAAU,GAAG,EAAE;EACnB,IAAI;IAAEC,GAAG;IAAEC;EAAI,CAAC,GAAGH,IAAI;EAEvB,IAAIG,GAAG,KAAK,CAAC,EAAEF,UAAU,CAACZ,IAAI,CAACL,IAAI,CAACkB,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;EAClD,IAAID,GAAG,KAAK,CAAC,EAAED,UAAU,CAACZ,IAAI,CAACL,IAAI,CAACkB,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;EAClD,IAAIA,GAAG,KAAKnB,IAAI,CAAC,CAAC,CAAC,CAACM,MAAM,GAAG,CAAC,EAAEW,UAAU,CAACZ,IAAI,CAACL,IAAI,CAACkB,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;EACnE,IAAID,GAAG,KAAKlB,IAAI,CAACM,MAAM,GAAG,CAAC,EAAEW,UAAU,CAACZ,IAAI,CAACL,IAAI,CAACkB,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;EAEhE,OAAOF,UAAU,CAACG,MAAM,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACX,SAAS,CAAC;AAEjE;AAEA,OAAO,SAASY,mBAAmBA,CAACpB,UAAU,EAAE;EAE5C,IAAIqB,wBAAwB,GAAG,EAAE;EACjC,IAAIC,WAAW,GAAGtB,UAAU;EAE5B,OAAOsB,WAAW,KAAK,IAAI,EAAE;IACzBD,wBAAwB,CAACR,OAAO,CAACS,WAAW,CAAC;IAC7CA,WAAW,GAAGA,WAAW,CAACV,YAAY;EAC1C;EAEA,OAAOS,wBAAwB;AAEnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
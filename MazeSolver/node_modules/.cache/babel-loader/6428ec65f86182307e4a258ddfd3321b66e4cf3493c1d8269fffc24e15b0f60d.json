{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) return;\n\n  // NOTE: dir === 0 => Horizontal\n  // NOTE: dir === 1 => Vertical\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) randomNum -= 1;else randomNum += 1;\n  }\n  return array[randomNum];\n}\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\nfunction generateRandomNumber(max) {\n  let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) randomNum -= 1;else randomNum += 1;\n  }\n  return randomNum;\n}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getRecursiveWalls","len","result","i","push","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","splice","generateRandomNumber","wall"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/maze_algorithms/recursiveDivisionMaze.js"],"sourcesContent":["let walls;\r\n\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let vertical = range(grid[0].length);\r\n    let horizontal = range(grid.length);\r\n\r\n    walls = [];\r\n    getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\r\n\r\n    return walls;\r\n\r\n}\r\n\r\nfunction range(len) {\r\n\r\n    let result = [];\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n\r\n    return result;\r\n\r\n}\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\r\n\r\n    if (vertical.length < 2 || horizontal.length < 2) return;\r\n\r\n    // NOTE: dir === 0 => Horizontal\r\n    // NOTE: dir === 1 => Vertical\r\n    let dir;\r\n    let num;\r\n\r\n    if (vertical.length > horizontal.length) {\r\n        dir = 0;\r\n        num = generateOddRandomNumber(vertical);\r\n    }\r\n\r\n    if (vertical.length <= horizontal.length) {\r\n        dir = 1;\r\n        num = generateOddRandomNumber(horizontal);\r\n    }\r\n\r\n    if (dir === 0) {\r\n\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n\r\n        getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\r\n\r\n        getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\r\n\r\n    } else {\r\n\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n\r\n        getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\r\n\r\n        getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n\r\n    let max = array.length - 1;\r\n\r\n    let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\r\n\r\n    if (randomNum % 2 === 0) {\r\n\r\n        if (randomNum === max) randomNum -= 1;\r\n        else randomNum += 1;\r\n\r\n    }\r\n\r\n    return array[randomNum];\r\n\r\n}\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n\r\n    if (dir === 0) {\r\n\r\n        if (horizontal.length === 2) return;\r\n\r\n        for (let temp of horizontal) {\r\n            if ((temp === startNode.row && num === startNode.col) ||\r\n                (temp === finishNode.row && num === finishNode.col)) {\r\n\r\n                isStartFinish = true;\r\n                continue;\r\n\r\n            }\r\n\r\n            tempWalls.push([temp, num]);\r\n\r\n        }\r\n\r\n    } else {\r\n\r\n        if (vertical.length === 2) return;\r\n\r\n        for (let temp of vertical) {\r\n            if ((num === startNode.row && temp === startNode.col) ||\r\n                (num === finishNode.row && temp === finishNode.col)) {\r\n\r\n                isStartFinish = true;\r\n                continue;\r\n\r\n            }\r\n\r\n            tempWalls.push([num, temp]);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    if (!isStartFinish) tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall);\r\n    }\r\n\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n\r\n    let randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\r\n\r\n    if (randomNum % 2 !== 0) {\r\n\r\n        if (randomNum === max) randomNum -= 1;\r\n        else randomNum += 1;\r\n\r\n    }\r\n\r\n    return randomNum;\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
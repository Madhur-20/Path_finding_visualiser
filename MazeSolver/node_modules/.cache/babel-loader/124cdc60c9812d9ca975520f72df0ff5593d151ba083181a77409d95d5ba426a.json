{"ast":null,"code":"export function randomWalk(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let visitedNodesInOrder = [];\n  let closestNode = startNode;\n  let maxNodes = grid.length * grid[0].length;\n  let maxNodesVisitedTracker = 0;\n  let loopTracker = 0;\n  while (true) {\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\n    let nodesVisited = numNodesVisited(grid);\n    if (nodesVisited === maxNodes - 2) return visitedNodesInOrder;\n    if (nodesVisited > maxNodesVisitedTracker) {\n      maxNodesVisitedTracker = nodesVisited;\n      loopTracker = 0;\n    } else if (nodesVisited = maxNodesVisitedTracker) {\n      loopTracker += 1;\n      if (loopTracker > 1000) return visitedNodesInOrder;\n    }\n    randomNeighbour.previousNode = closestNode;\n    closestNode = randomNeighbour;\n  }\n}\nfunction getRandomNeighbour(node, grid, finishNode) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  let neighboursFilteredStartAndWall = neighbours.filter(neighbour => !neighbour.isStart && !neighbour.isWall);\n  let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter(neighbour => !neighbour.isVisited);\n  if (neighboursFilteredVisited.length > 0) {\n    return neighboursFilteredVisited[Math.floor(Math.random() * neighboursFilteredVisited.length)];\n  }\n  return neighboursFilteredStartAndWall[Math.floor(Math.random() * neighboursFilteredStartAndWall.length)];\n}\nfunction numNodesVisited(grid) {\n  let count = 0;\n  for (let row of grid) {\n    for (let node of row) {\n      if (node.isVisited || node.isWall) count += 1;\n    }\n  }\n  return count;\n}","map":{"version":3,"names":["randomWalk","grid","startNode","finishNode","visitedNodesInOrder","closestNode","maxNodes","length","maxNodesVisitedTracker","loopTracker","isVisited","push","randomNeighbour","getRandomNeighbour","nodesVisited","numNodesVisited","previousNode","node","neighbours","row","col","neighboursFilteredStartAndWall","filter","neighbour","isStart","isWall","neighboursFilteredVisited","Math","floor","random","count"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/search_algorithms/randomWalk.js"],"sourcesContent":["export function randomWalk(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let visitedNodesInOrder = [];\r\n    let closestNode = startNode;\r\n    let maxNodes = grid.length * grid[0].length;\r\n    let maxNodesVisitedTracker = 0;\r\n    let loopTracker = 0;\r\n\r\n    while (true) {\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\r\n        let nodesVisited = numNodesVisited(grid);\r\n\r\n        if (nodesVisited === maxNodes - 2) return visitedNodesInOrder;\r\n\r\n        if (nodesVisited > maxNodesVisitedTracker) {\r\n\r\n            maxNodesVisitedTracker = nodesVisited;\r\n            loopTracker = 0;\r\n\r\n        } else if ((nodesVisited = maxNodesVisitedTracker)) {\r\n\r\n            loopTracker += 1;\r\n            if (loopTracker > 1000) return visitedNodesInOrder;\r\n\r\n        }\r\n\r\n        randomNeighbour.previousNode = closestNode;\r\n        closestNode = randomNeighbour;\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction getRandomNeighbour(node, grid, finishNode) {\r\n\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n\r\n    let neighboursFilteredStartAndWall = neighbours.filter((neighbour) => !neighbour.isStart && !neighbour.isWall);\r\n    let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter((neighbour) => !neighbour.isVisited);\r\n\r\n    if (neighboursFilteredVisited.length > 0) {\r\n        return neighboursFilteredVisited[Math.floor(Math.random() * neighboursFilteredVisited.length)];\r\n    }\r\n\r\n    return neighboursFilteredStartAndWall[Math.floor(Math.random() * neighboursFilteredStartAndWall.length)];\r\n\r\n}\r\n\r\nfunction numNodesVisited(grid) {\r\n\r\n    let count = 0;\r\n\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            if (node.isVisited || node.isWall) count += 1;\r\n        }\r\n    }\r\n\r\n    return count;\r\n    \r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
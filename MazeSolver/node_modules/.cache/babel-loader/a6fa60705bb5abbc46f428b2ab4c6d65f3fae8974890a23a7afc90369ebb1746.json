{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\nfunction getNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall).filter(neighbour => !neighbour.isVisited);\n}\nexport function getOptPathNodes_Dijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","nodes","row","node","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbours","col","filter","neighbour","getOptPathNodes_Dijkstra","nodesInShortestPathOrder","currentNode","unshift"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/search_algorithms/dijkstra.js"],"sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    startNode.distance = 0;\r\n    let unvisitedNodes = getNodes(grid);\r\n    let visitedNodesInOrder = [];\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n\r\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        updateUnvisitedNeighbours(closestNode, grid);\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction getNodes(grid) {\r\n\r\n    let nodes = [];\r\n\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n\r\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n        unvisitedNeighbour.distance = node.distance + 1;\r\n        unvisitedNeighbour.previousNode = node;\r\n    }\r\n\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n\r\n    return neighbours\r\n        .filter((neighbour) => !neighbour.isWall)\r\n        .filter((neighbour) => !neighbour.isVisited);\r\n\r\n}\r\n\r\nexport function getOptPathNodes_Dijkstra(finishNode) {\r\n\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPathOrder;\r\n\r\n}"],"mappings":"AAAA,OAAO,SAASA,QAAQA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAElD,IAAI,CAACD,SAAS,IAAI,CAACC,UAAU,IAAID,SAAS,KAAKC,UAAU,EAAE,OAAO,KAAK;EAEvED,SAAS,CAACE,QAAQ,GAAG,CAAC;EACtB,IAAIC,cAAc,GAAGC,QAAQ,CAACL,IAAI,CAAC;EACnC,IAAIM,mBAAmB,GAAG,EAAE;EAE5B,OAAOF,cAAc,CAACG,MAAM,KAAK,CAAC,EAAE;IAEhCH,cAAc,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACN,QAAQ,GAAGO,CAAC,CAACP,QAAQ,CAAC;IAEtD,IAAIQ,WAAW,GAAGP,cAAc,CAACQ,KAAK,CAAC,CAAC;IAExC,IAAID,WAAW,CAACE,MAAM,EAAE;IACxB,IAAIF,WAAW,CAACR,QAAQ,KAAKW,QAAQ,EAAE,OAAOR,mBAAmB;IACjE,IAAIK,WAAW,KAAKT,UAAU,EAAE,OAAOI,mBAAmB;IAE1DK,WAAW,CAACI,SAAS,GAAG,IAAI;IAC5BT,mBAAmB,CAACU,IAAI,CAACL,WAAW,CAAC;IACrCM,yBAAyB,CAACN,WAAW,EAAEX,IAAI,CAAC;EAEhD;AAEJ;AAEA,SAASK,QAAQA,CAACL,IAAI,EAAE;EAEpB,IAAIkB,KAAK,GAAG,EAAE;EAEd,KAAK,IAAIC,GAAG,IAAInB,IAAI,EAAE;IAClB,KAAK,IAAIoB,IAAI,IAAID,GAAG,EAAE;MAClBD,KAAK,CAACF,IAAI,CAACI,IAAI,CAAC;IACpB;EACJ;EAEA,OAAOF,KAAK;AAEhB;AAEA,SAASD,yBAAyBA,CAACG,IAAI,EAAEpB,IAAI,EAAE;EAE3C,IAAIqB,mBAAmB,GAAGC,sBAAsB,CAACF,IAAI,EAAEpB,IAAI,CAAC;EAE5D,KAAK,IAAIuB,kBAAkB,IAAIF,mBAAmB,EAAE;IAChDE,kBAAkB,CAACpB,QAAQ,GAAGiB,IAAI,CAACjB,QAAQ,GAAG,CAAC;IAC/CoB,kBAAkB,CAACC,YAAY,GAAGJ,IAAI;EAC1C;AAEJ;AAEA,SAASE,sBAAsBA,CAACF,IAAI,EAAEpB,IAAI,EAAE;EAExC,IAAIyB,UAAU,GAAG,EAAE;EACnB,IAAI;IAAEN,GAAG;IAAEO;EAAI,CAAC,GAAGN,IAAI;EAEvB,IAAID,GAAG,KAAK,CAAC,EAAEM,UAAU,CAACT,IAAI,CAAChB,IAAI,CAACmB,GAAG,GAAG,CAAC,CAAC,CAACO,GAAG,CAAC,CAAC;EAClD,IAAIA,GAAG,KAAK1B,IAAI,CAAC,CAAC,CAAC,CAACO,MAAM,GAAG,CAAC,EAAEkB,UAAU,CAACT,IAAI,CAAChB,IAAI,CAACmB,GAAG,CAAC,CAACO,GAAG,GAAG,CAAC,CAAC,CAAC;EACnE,IAAIP,GAAG,KAAKnB,IAAI,CAACO,MAAM,GAAG,CAAC,EAAEkB,UAAU,CAACT,IAAI,CAAChB,IAAI,CAACmB,GAAG,GAAG,CAAC,CAAC,CAACO,GAAG,CAAC,CAAC;EAChE,IAAIA,GAAG,KAAK,CAAC,EAAED,UAAU,CAACT,IAAI,CAAChB,IAAI,CAACmB,GAAG,CAAC,CAACO,GAAG,GAAG,CAAC,CAAC,CAAC;EAElD,OAAOD,UAAU,CACZE,MAAM,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACf,MAAM,CAAC,CACxCc,MAAM,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACb,SAAS,CAAC;AAEpD;AAEA,OAAO,SAASc,wBAAwBA,CAAC3B,UAAU,EAAE;EAEjD,IAAI4B,wBAAwB,GAAG,EAAE;EACjC,IAAIC,WAAW,GAAG7B,UAAU;EAE5B,OAAO6B,WAAW,KAAK,IAAI,EAAE;IACzBD,wBAAwB,CAACE,OAAO,CAACD,WAAW,CAAC;IAC7CA,WAAW,GAAGA,WAAW,CAACP,YAAY;EAC1C;EAEA,OAAOM,wBAAwB;AAEnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) return;\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) addWall(num, horizontal, startNode, finishNode);\n    if (choice === 1 && num % 2 === 0) addWall(num, horizontal, startNode, finishNode);\n  }\n}\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","map":{"version":3,"names":["walls","verticalMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getVerticalWalls","len","result","i","push","choice","Math","floor","random","num","addWall","isStartFinish","tempWalls","temp","row","col","splice","wall"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/maze_algorithms/verticalMaze.js"],"sourcesContent":["let walls;\r\n\r\nexport function verticalMaze(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let vertical = range(grid[0].length);\r\n    let horizontal = range(grid.length);\r\n\r\n    walls = [];\r\n    getVerticalWalls(vertical, horizontal, startNode, finishNode);\r\n\r\n    return walls;\r\n\r\n}\r\n\r\nfunction range(len) {\r\n\r\n    let result = [];\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n\r\n    return result;\r\n\r\n}\r\n\r\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\r\n\r\n    if (vertical.length < 2) return;\r\n\r\n    let choice = Math.floor(Math.random() * 2);\r\n\r\n    for (let num of vertical) {\r\n\r\n        if (choice === 0 && num % 2 !== 0) addWall(num, horizontal, startNode, finishNode);\r\n\r\n        if (choice === 1 && num % 2 === 0) addWall(num, horizontal, startNode, finishNode);\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction addWall(num, horizontal, startNode, finishNode) {\r\n\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n\r\n    for (let temp of horizontal) {\r\n        if ((temp === startNode.row && num === startNode.col) ||\r\n            (temp === finishNode.row && num === finishNode.col)) {\r\n\r\n            isStartFinish = true;\r\n            continue;\r\n\r\n        }\r\n\r\n        tempWalls.push([temp, num]);\r\n\r\n    }\r\n\r\n    if (!isStartFinish) tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall);\r\n    }\r\n\r\n}"],"mappings":"AAAA,IAAIA,KAAK;AAET,OAAO,SAASC,YAAYA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAEtD,IAAI,CAACD,SAAS,IAAI,CAACC,UAAU,IAAID,SAAS,KAAKC,UAAU,EAAE,OAAO,KAAK;EAEvE,IAAIC,QAAQ,GAAGC,KAAK,CAACJ,IAAI,CAAC,CAAC,CAAC,CAACK,MAAM,CAAC;EACpC,IAAIC,UAAU,GAAGF,KAAK,CAACJ,IAAI,CAACK,MAAM,CAAC;EAEnCP,KAAK,GAAG,EAAE;EACVS,gBAAgB,CAACJ,QAAQ,EAAEG,UAAU,EAAEL,SAAS,EAAEC,UAAU,CAAC;EAE7D,OAAOJ,KAAK;AAEhB;AAEA,SAASM,KAAKA,CAACI,GAAG,EAAE;EAEhB,IAAIC,MAAM,GAAG,EAAE;EAEf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAC1BD,MAAM,CAACE,IAAI,CAACD,CAAC,CAAC;EAClB;EAEA,OAAOD,MAAM;AAEjB;AAEA,SAASF,gBAAgBA,CAACJ,QAAQ,EAAEG,UAAU,EAAEL,SAAS,EAAEC,UAAU,EAAE;EAEnE,IAAIC,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;EAEzB,IAAIO,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;EAE1C,KAAK,IAAIC,GAAG,IAAIb,QAAQ,EAAE;IAEtB,IAAIS,MAAM,KAAK,CAAC,IAAII,GAAG,GAAG,CAAC,KAAK,CAAC,EAAEC,OAAO,CAACD,GAAG,EAAEV,UAAU,EAAEL,SAAS,EAAEC,UAAU,CAAC;IAElF,IAAIU,MAAM,KAAK,CAAC,IAAII,GAAG,GAAG,CAAC,KAAK,CAAC,EAAEC,OAAO,CAACD,GAAG,EAAEV,UAAU,EAAEL,SAAS,EAAEC,UAAU,CAAC;EAEtF;AAEJ;AAEA,SAASe,OAAOA,CAACD,GAAG,EAAEV,UAAU,EAAEL,SAAS,EAAEC,UAAU,EAAE;EAErD,IAAIgB,aAAa,GAAG,KAAK;EACzB,IAAIC,SAAS,GAAG,EAAE;EAElB,KAAK,IAAIC,IAAI,IAAId,UAAU,EAAE;IACzB,IAAKc,IAAI,KAAKnB,SAAS,CAACoB,GAAG,IAAIL,GAAG,KAAKf,SAAS,CAACqB,GAAG,IAC/CF,IAAI,KAAKlB,UAAU,CAACmB,GAAG,IAAIL,GAAG,KAAKd,UAAU,CAACoB,GAAI,EAAE;MAErDJ,aAAa,GAAG,IAAI;MACpB;IAEJ;IAEAC,SAAS,CAACR,IAAI,CAAC,CAACS,IAAI,EAAEJ,GAAG,CAAC,CAAC;EAE/B;EAEA,IAAI,CAACE,aAAa,EAAEC,SAAS,CAACI,MAAM,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGI,SAAS,CAACd,MAAM,CAAC,EAAE,CAAC,CAAC;EAErF,KAAK,IAAImB,IAAI,IAAIL,SAAS,EAAE;IACxBrB,KAAK,CAACa,IAAI,CAACa,IAAI,CAAC;EACpB;AAEJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
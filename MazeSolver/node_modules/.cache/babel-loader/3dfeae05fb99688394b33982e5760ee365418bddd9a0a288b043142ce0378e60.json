{"ast":null,"code":"export function bidirGreedySearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let unvisitedNodesStart = [];\n  let visitedNodesInOrderStart = [];\n  let unvisitedNodesFinish = [];\n  let visitedNodesInOrderFinish = [];\n  startNode.distance = 0;\n  finishNode.distance = 0;\n  unvisitedNodesStart.push(startNode);\n  unvisitedNodesFinish.push(finishNode);\n  while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNodeStart = unvisitedNodesStart.shift();\n    let closestNodeFinish = unvisitedNodesFinish.shift();\n    closestNodeStart.isVisited = true;\n    closestNodeFinish.isVisited = true;\n    visitedNodesInOrderStart.push(closestNodeStart);\n    visitedNodesInOrderFinish.push(closestNodeFinish);\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n    }\n\n    // Start side search.\n    let neighbours = getNeighbours(closestNodeStart, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderFinish.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n      let distance = closestNodeStart.distance + 1;\n\n      // f(n) = h(n).\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        unvisitedNodesStart.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNodeStart;\n      }\n    }\n\n    // Finish side search.\n    neighbours = getNeighbours(closestNodeFinish, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        visitedNodesInOrderStart.push(closestNodeFinish);\n        visitedNodesInOrderStart.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n      let distance = closestNodeFinish.distance + 1;\n\n      //f(n) = h(n)\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n        unvisitedNodesFinish.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeFinish;\n      }\n    }\n  }\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n}\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\n  let rowStart = closestNodeStart.row;\n  let colStart = closestNodeStart.col;\n  let rowFinish = closestNodeFinish.row;\n  let colFinish = closestNodeFinish.col;\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n  return false;\n}\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\nfunction manhattenDistance(nodeA, nodeB) {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n}\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function getOptPathNodes_BidirGreedySearch(nodeA, nodeB) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  currentNode = nodeA;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["bidirGreedySearch","grid","startNode","finishNode","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","distance","push","length","sort","a","b","totalDistance","closestNodeStart","shift","closestNodeFinish","isVisited","isNeighbour","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","rowStart","row","colStart","col","rowFinish","colFinish","node","filter","isWall","nodeA","nodeB","x","Math","abs","y","unvisitedNodes","getOptPathNodes_BidirGreedySearch","nodesInShortestPathOrder","currentNode"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/search_algorithms/birdirGreedySearch.js"],"sourcesContent":["export function bidirGreedySearch(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let unvisitedNodesStart = [];\r\n    let visitedNodesInOrderStart = [];\r\n\r\n    let unvisitedNodesFinish = [];\r\n    let visitedNodesInOrderFinish = [];\r\n\r\n    startNode.distance = 0;\r\n    finishNode.distance = 0;\r\n\r\n    unvisitedNodesStart.push(startNode);\r\n    unvisitedNodesFinish.push(finishNode);\r\n\r\n    while (unvisitedNodesStart.length !== 0 && unvisitedNodesFinish.length !== 0) {\r\n\r\n        unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\r\n        unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\r\n\r\n        let closestNodeStart = unvisitedNodesStart.shift();\r\n        let closestNodeFinish = unvisitedNodesFinish.shift();\r\n\r\n        closestNodeStart.isVisited = true;\r\n        closestNodeFinish.isVisited = true;\r\n\r\n        visitedNodesInOrderStart.push(closestNodeStart);\r\n        visitedNodesInOrderFinish.push(closestNodeFinish);\r\n\r\n        if (isNeighbour(closestNodeStart, closestNodeFinish)) {\r\n            return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n        }\r\n\r\n        // Start side search.\r\n        let neighbours = getNeighbours(closestNodeStart, grid);\r\n\r\n        for (let neighbour of neighbours) {\r\n\r\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n\r\n                visitedNodesInOrderStart.push(closestNodeStart);\r\n                visitedNodesInOrderFinish.push(neighbour);\r\n                return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n\r\n            }\r\n\r\n            let distance = closestNodeStart.distance + 1;\r\n\r\n            // f(n) = h(n).\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n\r\n                unvisitedNodesStart.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.previousNode = closestNodeStart;\r\n\r\n            } else if (distance < neighbour.distance) {\r\n\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.previousNode = closestNodeStart;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Finish side search.\r\n        neighbours = getNeighbours(closestNodeFinish, grid);\r\n\r\n        for (let neighbour of neighbours) {\r\n\r\n            if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n\r\n                visitedNodesInOrderStart.push(closestNodeFinish);\r\n                visitedNodesInOrderStart.push(neighbour);\r\n                return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n\r\n            }\r\n\r\n            let distance = closestNodeFinish.distance + 1;\r\n\r\n            //f(n) = h(n)\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n\r\n                unvisitedNodesFinish.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n                neighbour.previousNode = closestNodeFinish;\r\n\r\n            } else if (distance < neighbour.distance) {\r\n\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n                neighbour.previousNode = closestNodeFinish;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\r\n\r\n}\r\n\r\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\r\n\r\n    let rowStart = closestNodeStart.row;\r\n    let colStart = closestNodeStart.col;\r\n    let rowFinish = closestNodeFinish.row;\r\n    let colFinish = closestNodeFinish.col;\r\n\r\n    if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\r\n    if (rowFinish === rowStart && colFinish === colStart + 1) return true;\r\n    if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\r\n    if (rowFinish === rowStart && colFinish === colStart - 1) return true;\r\n\r\n    return false;\r\n\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n\r\n    return neighbours.filter((neighbour) => !neighbour.isWall && !neighbour.isVisited);\r\n\r\n}\r\n\r\nfunction manhattenDistance(nodeA, nodeB) {\r\n\r\n    let x = Math.abs(nodeA.row - nodeB.row);\r\n    let y = Math.abs(nodeA.col - nodeB.col);\r\n    return x + y;\r\n\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n\r\n    for (let node of unvisitedNodes) {\r\n        if (node.row === neighbour.row && node.col === neighbour.col) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n\r\n}\r\n\r\nexport function getOptPathNodes_BidirGreedySearch(nodeA, nodeB) {\r\n\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = nodeB;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.push(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    currentNode = nodeA;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPathOrder;\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
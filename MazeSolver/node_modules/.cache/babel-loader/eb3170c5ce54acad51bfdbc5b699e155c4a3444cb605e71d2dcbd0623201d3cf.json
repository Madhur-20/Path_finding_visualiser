{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\Desktop\\\\PathFinding Visualiser\\\\MazeSolver\\\\src\\\\components\\\\MazeSolver.jsx\";\nimport React, { Component } from \"react\";\nimport \"./MazeSolver.css\";\n\n// Import components for creating the MazeSolver application.\nimport Node from \"./Node/Node\";\nimport NavBar from \"./NavBar/NavBar\";\nimport Pseudocode from \"./Pseudocode/Pseudocode\";\n\n// Import search algorithms for solving mazes.\nimport { randomWalk } from \"../search_algorithms/randomWalk\";\nimport { dijkstra, getOptPathNodes_Dijkstra } from \"../search_algorithms/dijkstra\";\nimport { breadthFirstSearch, getOptPathNodes_BFS } from \"../search_algorithms/breadthFirstSearch\";\nimport { depthFirstSearch, getOptPathNodes_DFS } from \"../search_algorithms/depthFirstSearch\";\nimport { aStar, getOptPathNodes_AStar } from \"../search_algorithms/astar\";\nimport { greedyBestFS, getOptPathNodes_GreedyBestFS } from \"../search_algorithms/greedyBestFirstSearch\";\nimport { bidirGreedySearch, getOptPathNodes_BidirGreedySearch } from \"../search_algorithms/birdirGreedySearch\";\n\n// Import maze generation algorithms.\nimport { randomMaze } from \"../maze_algorithms/randomMaze\";\nimport { recursiveDivisionMaze } from \"../maze_algorithms/recursiveDivisionMaze\";\nimport { verticalMaze } from \"../maze_algorithms/verticalMaze\";\nimport { horizontalMaze } from \"../maze_algorithms/horizontalMaze\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initDims = getInitDimensions(window.innerWidth, window.innerHeight);\nconst initNumRows = initDims[0];\nconst initNumCols = initDims[1];\nconst startFinishNode = getStartFinishNodes(initNumRows, initNumCols);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\nclass MazeSolver extends Component {\n  constructor(...args) {\n    super(...args);\n    // ATTRIBUTES (i.e., state):\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      visualizingAlgorithm: false,\n      generatingMaze: false,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      numRows: initNumRows,\n      numColumns: initNumCols,\n      speed: 10,\n      mazeSpeed: 10,\n      algorithm: \"Visualize Algorithm\"\n    };\n    // UTILITY METHODS:\n    this.updateAlgorithm = newAlgorithm => {\n      this.setState({\n        algorithm: newAlgorithm\n      });\n    };\n    this.updateDimensions = () => {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    this.updateSpeed = (path, maze) => {\n      this.setState({\n        speed: path,\n        mazeSpeed: maze\n      });\n    };\n    // SEARCH ALGORITHM METHODS:\n    this.animateShortestPath = (nodesOptPathOrdered, nodesVisitedOrdered) => {\n      if (nodesOptPathOrdered.length === 1) this.setState({\n        visualizingAlgorithm: false\n      });\n      for (let i = 1; i < nodesOptPathOrdered.length; i++) {\n        if (i === nodesOptPathOrdered.length - 1) {\n          setTimeout(() => {\n            let newGrid = updateNodesForRender(this.state.grid, nodesOptPathOrdered, nodesVisitedOrdered);\n            this.setState({\n              grid: newGrid,\n              visualizingAlgorithm: false\n            });\n          }, i * (3 * this.state.speed));\n          return;\n        }\n        let node = nodesOptPathOrdered[i];\n        setTimeout(() => {\n          // Shortest path node.\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n        }, i * (3 * this.state.speed));\n      }\n    };\n    this.animateAlgorithm = (nodesVisitedOrdered, nodesOptPathOrdered) => {\n      let newGrid = this.state.grid.slice();\n      for (let row of newGrid) {\n        for (let node of row) {\n          let newNode = {\n            ...node,\n            isVisited: false\n          };\n          newGrid[node.row][node.col] = newNode;\n        }\n      }\n      this.setState({\n        grid: newGrid\n      });\n      for (let i = 1; i <= nodesVisitedOrdered.length; i++) {\n        let node = nodesVisitedOrdered[i];\n        if (i === nodesVisitedOrdered.length) {\n          setTimeout(() => {\n            this.animateShortestPath(nodesOptPathOrdered, nodesVisitedOrdered);\n          }, i * this.state.speed);\n          return;\n        }\n        setTimeout(() => {\n          // Visited node.\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n    this.animateRandomWalk = nodesVisitedOrdered => {\n      for (let i = 1; i <= nodesVisitedOrdered.length; i++) {\n        if (i === nodesVisitedOrdered.length) {\n          setTimeout(() => {\n            this.setState({\n              visualizingAlgorithm: false\n            });\n          }, i * this.state.speed);\n          return;\n        }\n        let node = nodesVisitedOrdered[i];\n        if (i === nodesVisitedOrdered.length - 1) {\n          setTimeout(() => {\n            // Finish node.\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish-reached\";\n          }, i * this.state.speed);\n          continue;\n        }\n        setTimeout(() => {\n          // Visited node.\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n        }, i * this.state.speed);\n      }\n    };\n    // MAZE METHODS:\n    this.animateMaze = walls => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            this.clearGrid();\n            let newGrid = getNewGridWithMaze(this.state.grid, walls);\n            this.setState({\n              grid: newGrid,\n              generatingMaze: false\n            });\n          }, i * this.state.mazeSpeed);\n          return;\n        }\n        let wall = walls[i];\n        let node = this.state.grid[wall[0]][wall[1]];\n        setTimeout(() => {\n          // Walls.\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall-animated\";\n        }, i * this.state.mazeSpeed);\n      }\n    };\n  }\n  componentDidMount() {\n    window.addEventListener(\"resize\", this.updateDimensions);\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid\n    });\n  }\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n    this.setState({\n      grid: newGrid,\n      mouseIsPressed: true\n    });\n  }\n  handleMouseEnter(row, col) {\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n  clearGrid() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (!(row === startNodeRow && col === startNodeCol || row === finishNodeRow && col === finishNodeCol)) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n  clearPath() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    for (let row = 0; row < this.state.grid.length; row++) {\n      for (let col = 0; col < this.state.grid[0].length; col++) {\n        if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(this.state.grid);\n    this.setState({\n      grid: newGrid,\n      visualizingAlgorithm: false,\n      generatingMaze: false\n    });\n  }\n  animateBidirectionalAlgorithm(nodesVisitedOrderedStart, nodesVisitedOrderedFinish, nodesOptPathOrdered, isShortedPath) {\n    let len = Math.max(nodesVisitedOrderedStart.length, nodesVisitedOrderedFinish.length);\n    for (let i = 1; i <= len; i++) {\n      let nodeA = nodesVisitedOrderedStart[i];\n      let nodeB = nodesVisitedOrderedFinish[i];\n      if (i === nodesVisitedOrderedStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(nodesVisitedOrderedStart, nodesVisitedOrderedFinish);\n          if (isShortedPath) {\n            this.animateShortestPath(nodesOptPathOrdered, visitedNodesInOrder);\n          } else {\n            this.setState({\n              visualizingAlgorithm: false\n            });\n          }\n        }, i * this.state.speed);\n        return;\n      }\n      setTimeout(() => {\n        // Visited nodes.\n        if (nodeA !== undefined) {\n          document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = \"node node-visited\";\n        }\n        if (nodeB !== undefined) {\n          document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = \"node node-visited\";\n        }\n      }, i * this.state.speed);\n    }\n  }\n  visualizeDijkstra() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getOptPathNodes_Dijkstra(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n  visualizeAStar() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = aStar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getOptPathNodes_AStar(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n  visualizeBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getOptPathNodes_BFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n  visualizeDFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getOptPathNodes_DFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n  visualizeRandomWalk() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\n      this.animateRandomWalk(visitedNodesInOrder);\n    }, this.state.speed);\n  }\n  visualizeGreedyBFS() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = greedyBestFS(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getOptPathNodes_GreedyBestFS(finishNode);\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, this.state.speed);\n  }\n  visualizeBidirectionalGreedySearch() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      visualizingAlgorithm: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = bidirGreedySearch(grid, startNode, finishNode);\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderFinish = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      const nodesInShortestPathOrder = getOptPathNodes_BidirGreedySearch(visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1], visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]);\n      this.animateBidirectionalAlgorithm(visitedNodesInOrderStart, visitedNodesInOrderFinish, nodesInShortestPathOrder, isShortedPath);\n    }, this.state.speed);\n  }\n  generateRandomMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = randomMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n  generateRecursiveDivisionMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n  generateVerticalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n  generateHorizontalMaze() {\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\n    this.setState({\n      generatingMaze: true\n    });\n    setTimeout(() => {\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      this.animateMaze(walls);\n    }, this.state.mazeSpeed);\n  }\n\n  // MAIN RENDER METHOD:\n  // Required for components.\n\n  render() {\n    let {\n      grid\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(NavBar, {\n        visualizingAlgorithm: this.state.visualizingAlgorithm,\n        generatingMaze: this.state.generatingMaze,\n        visualizeDijkstra: this.visualizeDijkstra.bind(this),\n        visualizeAStar: this.visualizeAStar.bind(this),\n        visualizeGreedyBFS: this.visualizeGreedyBFS.bind(this),\n        visualizeBidirectionalGreedySearch: this.visualizeBidirectionalGreedySearch.bind(this),\n        visualizeBFS: this.visualizeBFS.bind(this),\n        visualizeDFS: this.visualizeDFS.bind(this),\n        visualizeRandomWalk: this.visualizeRandomWalk.bind(this),\n        generateRandomMaze: this.generateRandomMaze.bind(this),\n        generateRecursiveDivisionMaze: this.generateRecursiveDivisionMaze.bind(this),\n        generateVerticalMaze: this.generateVerticalMaze.bind(this),\n        generateHorizontalMaze: this.generateHorizontalMaze.bind(this),\n        clearGrid: this.clearGrid.bind(this),\n        clearPath: this.clearPath.bind(this),\n        updateSpeed: this.updateSpeed.bind(this),\n        algorithm: this.state.algorithm,\n        updateAlgorithm: this.updateAlgorithm.bind(this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 629,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-instructions\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [/*#__PURE__*/_jsxDEV(\"i\", {\n            children: \"Click\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 659,\n            columnNumber: 25\n          }, this), \" or \", /*#__PURE__*/_jsxDEV(\"i\", {\n            children: \"drag\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 659,\n            columnNumber: 41\n          }, this), \" within the grid to toggle walls.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 659,\n            columnNumber: 85\n          }, this), \"Alternatively, create a maze using the options above.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 660,\n            columnNumber: 78\n          }, this), \"Then, select a pathfinding algorithm and visualize it!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 658,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 657,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"gridKey\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"keyItem\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyIcon\",\n            children: /*#__PURE__*/_jsxDEV(Node, {\n              row: -1,\n              col: -1,\n              isStart: true,\n              isFinish: false,\n              isVisited: false,\n              isShortest: false,\n              isWall: false,\n              width: this.state.width * 1.3,\n              height: this.state.height * 1.3,\n              numRows: this.state.numRows,\n              numColumns: this.state.numColumns\n            }, \"key-node-start\", false, {\n              fileName: _jsxFileName,\n              lineNumber: 671,\n              columnNumber: 25\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 669,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyLabel\",\n            children: \"Start Node\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 691,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 668,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"keyItem\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyIcon\",\n            children: /*#__PURE__*/_jsxDEV(Node, {\n              row: -1,\n              col: -1,\n              isStart: false,\n              isFinish: true,\n              isVisited: false,\n              isShortest: false,\n              isWall: false,\n              width: this.state.width * 1.3,\n              height: this.state.height * 1.3,\n              numRows: this.state.numRows,\n              numColumns: this.state.numColumns\n            }, \"key-node-finish\", false, {\n              fileName: _jsxFileName,\n              lineNumber: 696,\n              columnNumber: 25\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 695,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyLabel\",\n            children: \"Goal Node\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 716,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 694,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"keyItem\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyIcon\",\n            children: /*#__PURE__*/_jsxDEV(Node, {\n              row: -1,\n              col: -1,\n              isStart: false,\n              isFinish: false,\n              isVisited: false,\n              isShortest: false,\n              isWall: true,\n              width: this.state.width * 1.3,\n              height: this.state.height * 1.3,\n              numRows: this.state.numRows,\n              numColumns: this.state.numColumns\n            }, \"key-node-wall\", false, {\n              fileName: _jsxFileName,\n              lineNumber: 721,\n              columnNumber: 25\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 720,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"keyLabel\",\n            children: \"Wall Node\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 741,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 719,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 666,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: this.state.visualizingAlgorithm || this.state.generatingMaze ? \"grid-visualizing\" : \"grid\",\n        children: grid.map((row, rowId) => {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: row.map((node, nodeId) => {\n              const {\n                row,\n                col,\n                isStart,\n                isFinish,\n                isVisited,\n                isShortest,\n                isWall\n              } = node;\n              return /*#__PURE__*/_jsxDEV(Node, {\n                row: row,\n                col: col,\n                isStart: isStart,\n                isFinish: isFinish,\n                isVisited: isVisited,\n                isShortest: isShortest,\n                isWall: isWall,\n                onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n                onMouseUp: () => this.handleMouseUp(),\n                width: this.state.width,\n                height: this.state.height,\n                numRows: this.state.numRows,\n                numColumns: this.state.numColumns\n              }, nodeId, false, {\n                fileName: _jsxFileName,\n                lineNumber: 770,\n                columnNumber: 41\n              }, this);\n            })\n          }, rowId, false, {\n            fileName: _jsxFileName,\n            lineNumber: 754,\n            columnNumber: 29\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 747,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Pseudocode, {\n        algorithm: this.state.algorithm,\n        updateAlgorithm: this.updateAlgorithm.bind(this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 805,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 626,\n      columnNumber: 13\n    }, this);\n  }\n} // MazeSolver{}.\n\nfunction getInitDimensions(width, height) {\n  let numCols;\n  if (width > 1500) numCols = Math.floor(width / 25);else if (width > 1250) numCols = Math.floor(width / 22.5);else if (width > 1000) numCols = Math.floor(width / 20);else if (width > 750) numCols = Math.floor(width / 17.5);else if (width > 500) numCols = Math.floor(width / 15);else if (width > 250) numCols = Math.floor(width / 12.5);else if (width > 0) numCols = Math.floor(width / 10);\n  let cellWidth = Math.floor(width / numCols);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numCols];\n}\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\nfunction getStartFinishNodes(numRows, numColumns) {\n  let randNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + randNums[1][Math.floor(Math.random() * randNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow = x + randNums[0][Math.floor(Math.random() * randNums[0].length)];\n    finishNodeCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol = y + randNums[1][Math.floor(Math.random() * randNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol = y + randNums[0][Math.floor(Math.random() * randNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) currentRow.push(createNode(row, col));\n    grid.push(currentRow);\n  }\n  return grid;\n};\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null\n  };\n};\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice();\n  let node = grid[row][col];\n  let newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\nconst updateNodesForRender = (grid, nodesOptimalPathOrdered, nodesVisitedOrdered) => {\n  let newGrid = grid.slice();\n  for (let node of nodesVisitedOrdered) {\n    if (node.row === startNodeRow && node.col === startNodeCol || node.row === finishNodeRow && node.col === finishNodeCol) continue;\n    let newNode = {\n      ...node,\n      isVisited: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesOptimalPathOrdered) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) return newGrid;\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\nconst getVisitedNodesInOrder = (nodesVisitedOrderedStart, nodesVisitedOrderedFinish) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(nodesVisitedOrderedStart.length, nodesVisitedOrderedFinish.length);\n  for (let i = 0; i < n; i++) {\n    if (nodesVisitedOrderedStart[i] !== undefined) visitedNodesInOrder.push(nodesVisitedOrderedStart[i]);\n    if (nodesVisitedOrderedFinish[i] !== undefined) visitedNodesInOrder.push(nodesVisitedOrderedFinish[i]);\n  }\n  return visitedNodesInOrder;\n};\nexport default MazeSolver;","map":{"version":3,"names":["React","Component","Node","NavBar","Pseudocode","randomWalk","dijkstra","getOptPathNodes_Dijkstra","breadthFirstSearch","getOptPathNodes_BFS","depthFirstSearch","getOptPathNodes_DFS","aStar","getOptPathNodes_AStar","greedyBestFS","getOptPathNodes_GreedyBestFS","bidirGreedySearch","getOptPathNodes_BidirGreedySearch","randomMaze","recursiveDivisionMaze","verticalMaze","horizontalMaze","jsxDEV","_jsxDEV","initDims","getInitDimensions","window","innerWidth","innerHeight","initNumRows","initNumCols","startFinishNode","getStartFinishNodes","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","MazeSolver","constructor","args","state","grid","mouseIsPressed","visualizingAlgorithm","generatingMaze","width","height","numRows","numColumns","speed","mazeSpeed","algorithm","updateAlgorithm","newAlgorithm","setState","updateDimensions","updateSpeed","path","maze","animateShortestPath","nodesOptPathOrdered","nodesVisitedOrdered","length","i","setTimeout","newGrid","updateNodesForRender","node","document","getElementById","row","col","className","animateAlgorithm","slice","newNode","isVisited","animateRandomWalk","animateMaze","walls","clearGrid","getNewGridWithMaze","wall","componentDidMount","addEventListener","getInitialGrid","handleMouseDown","getNewGridWithWalls","handleMouseEnter","handleMouseUp","clearPath","getGridWithoutPath","animateBidirectionalAlgorithm","nodesVisitedOrderedStart","nodesVisitedOrderedFinish","isShortedPath","len","Math","max","nodeA","nodeB","visitedNodesInOrder","getVisitedNodesInOrder","undefined","visualizeDijkstra","startNode","finishNode","nodesInShortestPathOrder","visualizeAStar","visualizeBFS","visualizeDFS","visualizeRandomWalk","visualizeGreedyBFS","visualizeBidirectionalGreedySearch","visitedNodesInOrderStart","visitedNodesInOrderFinish","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","render","Fragment","children","bind","fileName","_jsxFileName","lineNumber","columnNumber","isStart","isFinish","isShortest","isWall","map","rowId","nodeId","onMouseDown","onMouseEnter","onMouseUp","numCols","floor","cellWidth","getRandomNums","num","randomNums1","temp","push","randomNums2","randNums","x","y","random","currentRow","createNode","distance","Infinity","totalDistance","previousNode","nodesOptimalPathOrdered","n"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/components/MazeSolver.jsx"],"sourcesContent":["import React, {Component} from \"react\";\r\nimport \"./MazeSolver.css\";\r\n\r\n// Import components for creating the MazeSolver application.\r\nimport Node from \"./Node/Node\";\r\nimport NavBar from \"./NavBar/NavBar\";\r\nimport Pseudocode from \"./Pseudocode/Pseudocode\";\r\n\r\n// Import search algorithms for solving mazes.\r\nimport {randomWalk} from \"../search_algorithms/randomWalk\"\r\nimport {dijkstra, getOptPathNodes_Dijkstra,} from \"../search_algorithms/dijkstra\";\r\nimport {breadthFirstSearch, getOptPathNodes_BFS} from \"../search_algorithms/breadthFirstSearch\";\r\nimport {depthFirstSearch, getOptPathNodes_DFS} from \"../search_algorithms/depthFirstSearch\";\r\nimport {aStar, getOptPathNodes_AStar,} from \"../search_algorithms/astar\";\r\nimport {greedyBestFS, getOptPathNodes_GreedyBestFS} from \"../search_algorithms/greedyBestFirstSearch\";\r\nimport {bidirGreedySearch, getOptPathNodes_BidirGreedySearch} from \"../search_algorithms/birdirGreedySearch\";\r\n\r\n// Import maze generation algorithms.\r\nimport {randomMaze} from \"../maze_algorithms/randomMaze\";\r\nimport {recursiveDivisionMaze} from \"../maze_algorithms/recursiveDivisionMaze\";\r\nimport {verticalMaze} from \"../maze_algorithms/verticalMaze\";\r\nimport {horizontalMaze} from \"../maze_algorithms/horizontalMaze\";\r\n\r\nconst initDims = getInitDimensions(window.innerWidth, window.innerHeight);\r\nconst initNumRows = initDims[0];\r\nconst initNumCols = initDims[1];\r\n\r\nconst startFinishNode = getStartFinishNodes(initNumRows, initNumCols);\r\nconst startNodeRow = startFinishNode[0];\r\nconst startNodeCol = startFinishNode[1];\r\nconst finishNodeRow = startFinishNode[2];\r\nconst finishNodeCol = startFinishNode[3];\r\n\r\nclass MazeSolver extends Component {\r\n\r\n\r\n    // ATTRIBUTES (i.e., state):\r\n\r\n    state = {\r\n        grid: [],\r\n        mouseIsPressed: false,\r\n        visualizingAlgorithm: false,\r\n        generatingMaze: false,\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n        numRows: initNumRows,\r\n        numColumns: initNumCols,\r\n        speed: 10,\r\n        mazeSpeed: 10,\r\n        algorithm: \"Visualize Algorithm\",\r\n    };\r\n\r\n\r\n    // UTILITY METHODS:\r\n\r\n    updateAlgorithm = (newAlgorithm) => {\r\n\r\n        this.setState({\r\n            algorithm: newAlgorithm\r\n        })\r\n\r\n    }\r\n\r\n    updateDimensions = () => {\r\n\r\n        this.setState({\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        });\r\n\r\n    };\r\n\r\n    updateSpeed = (path, maze) => {\r\n\r\n        this.setState({\r\n            speed: path, mazeSpeed: maze\r\n        });\r\n\r\n    };\r\n\r\n    componentDidMount() {\r\n\r\n        window.addEventListener(\"resize\", this.updateDimensions);\r\n        const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\r\n        this.setState({ grid });\r\n\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n\r\n        const newGrid = getNewGridWithWalls(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n\r\n        if (this.state.mouseIsPressed) {\r\n            const newGrid = getNewGridWithWalls(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseUp() {\r\n\r\n        this.setState({\r\n            mouseIsPressed: false\r\n        });\r\n\r\n    }\r\n\r\n    clearGrid() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if (!((row === startNodeRow && col === startNodeCol) || (row === finishNodeRow && col === finishNodeCol))) {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n\r\n        const newGrid = getInitialGrid(this.state.numRows, this.state.numColumns);\r\n\r\n        this.setState({\r\n            grid: newGrid,\r\n            visualizingAlgorithm: false,\r\n            generatingMaze: false,\r\n        });\r\n\r\n    }\r\n\r\n    clearPath() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n\r\n        const newGrid = getGridWithoutPath(this.state.grid);\r\n\r\n        this.setState({\r\n            grid: newGrid,\r\n            visualizingAlgorithm: false,\r\n            generatingMaze: false,\r\n        });\r\n\r\n    }\r\n\r\n\r\n    // SEARCH ALGORITHM METHODS:\r\n\r\n    animateShortestPath = (nodesOptPathOrdered, nodesVisitedOrdered) => {\r\n\r\n        if (nodesOptPathOrdered.length === 1) this.setState({ visualizingAlgorithm: false });\r\n\r\n        for (let i = 1; i < nodesOptPathOrdered.length; i++) {\r\n\r\n            if (i === nodesOptPathOrdered.length - 1) {\r\n\r\n                setTimeout(() => {\r\n\r\n                    let newGrid = updateNodesForRender(\r\n                        this.state.grid,\r\n                        nodesOptPathOrdered,\r\n                        nodesVisitedOrdered\r\n                    );\r\n\r\n                    this.setState({\r\n                        grid: newGrid, visualizingAlgorithm: false\r\n                    });\r\n\r\n                }, i * (3 * this.state.speed));\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            let node = nodesOptPathOrdered[i];\r\n\r\n            setTimeout(() => {\r\n                // Shortest path node.\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\r\n            }, i * (3 * this.state.speed));\r\n\r\n        }\r\n\r\n    };\r\n\r\n    animateAlgorithm = (nodesVisitedOrdered, nodesOptPathOrdered) => {\r\n\r\n        let newGrid = this.state.grid.slice();\r\n\r\n        for (let row of newGrid) {\r\n            for (let node of row) {\r\n\r\n                let newNode = {\r\n                    ...node,\r\n                    isVisited: false,\r\n                };\r\n\r\n                newGrid[node.row][node.col] = newNode;\r\n\r\n            }\r\n        }\r\n\r\n        this.setState({\r\n            grid: newGrid\r\n        });\r\n\r\n        for (let i = 1; i <= nodesVisitedOrdered.length; i++) {\r\n\r\n            let node = nodesVisitedOrdered[i];\r\n\r\n            if (i === nodesVisitedOrdered.length) {\r\n\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesOptPathOrdered, nodesVisitedOrdered);\r\n                }, i * this.state.speed);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            setTimeout(() => {\r\n                // Visited node.\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\r\n            }, i * this.state.speed);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    animateRandomWalk = (nodesVisitedOrdered) => {\r\n\r\n        for (let i = 1; i <= nodesVisitedOrdered.length; i++) {\r\n\r\n            if (i === nodesVisitedOrdered.length) {\r\n\r\n                setTimeout(() => {\r\n                    this.setState({\r\n                        visualizingAlgorithm: false\r\n                    });\r\n                }, i * this.state.speed);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            let node = nodesVisitedOrdered[i];\r\n\r\n            if (i === nodesVisitedOrdered.length - 1) {\r\n\r\n                setTimeout(() => {\r\n                    // Finish node.\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish-reached\";\r\n                }, i * this.state.speed);\r\n\r\n                continue;\r\n\r\n            }\r\n\r\n            setTimeout(() => {\r\n                // Visited node.\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\r\n            }, i * this.state.speed);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    animateBidirectionalAlgorithm(nodesVisitedOrderedStart, nodesVisitedOrderedFinish, nodesOptPathOrdered, isShortedPath) {\r\n\r\n        let len = Math.max(nodesVisitedOrderedStart.length, nodesVisitedOrderedFinish.length);\r\n\r\n        for (let i = 1; i <= len; i++) {\r\n\r\n            let nodeA = nodesVisitedOrderedStart[i];\r\n            let nodeB = nodesVisitedOrderedFinish[i];\r\n\r\n            if (i === nodesVisitedOrderedStart.length) {\r\n\r\n                setTimeout(() => {\r\n                    let visitedNodesInOrder = getVisitedNodesInOrder(nodesVisitedOrderedStart, nodesVisitedOrderedFinish);\r\n\r\n                    if (isShortedPath) {\r\n                        this.animateShortestPath(nodesOptPathOrdered, visitedNodesInOrder);\r\n                    } else {\r\n                        this.setState({\r\n                            visualizingAlgorithm: false\r\n                        });\r\n                    }\r\n\r\n                }, i * this.state.speed);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            setTimeout(() => {\r\n\r\n                // Visited nodes.\r\n                if (nodeA !== undefined) {\r\n                    document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className = \"node node-visited\";\r\n                }\r\n\r\n                if (nodeB !== undefined) {\r\n                    document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className = \"node node-visited\";\r\n                }\r\n\r\n            }, i * this.state.speed);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    visualizeDijkstra() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getOptPathNodes_Dijkstra(finishNode);\r\n\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeAStar() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getOptPathNodes_AStar(finishNode);\r\n\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeBFS() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getOptPathNodes_BFS(finishNode);\r\n\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeDFS() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getOptPathNodes_DFS(finishNode);\r\n\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeRandomWalk() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\r\n\r\n            this.animateRandomWalk(visitedNodesInOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeGreedyBFS() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = greedyBestFS(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getOptPathNodes_GreedyBestFS(finishNode);\r\n\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n    visualizeBidirectionalGreedySearch() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            visualizingAlgorithm: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const visitedNodesInOrder = bidirGreedySearch(grid, startNode, finishNode);\r\n            const visitedNodesInOrderStart = visitedNodesInOrder[0];\r\n            const visitedNodesInOrderFinish = visitedNodesInOrder[1];\r\n            const isShortedPath = visitedNodesInOrder[2];\r\n            const nodesInShortestPathOrder = getOptPathNodes_BidirGreedySearch(\r\n                visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\r\n                visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\r\n            );\r\n\r\n            this.animateBidirectionalAlgorithm(visitedNodesInOrderStart, visitedNodesInOrderFinish,\r\n                nodesInShortestPathOrder, isShortedPath);\r\n\r\n        }, this.state.speed);\r\n\r\n    }\r\n\r\n\r\n    // MAZE METHODS:\r\n\r\n    animateMaze = (walls) => {\r\n\r\n        for (let i = 0; i <= walls.length; i++) {\r\n\r\n            if (i === walls.length) {\r\n\r\n                setTimeout(() => {\r\n\r\n                    this.clearGrid();\r\n                    let newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n                    this.setState({\r\n                        grid: newGrid,\r\n                        generatingMaze: false\r\n                    });\r\n\r\n                }, i * this.state.mazeSpeed);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            let wall = walls[i];\r\n            let node = this.state.grid[wall[0]][wall[1]];\r\n\r\n            setTimeout(() => {\r\n                // Walls.\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall-animated\";\r\n            }, i * this.state.mazeSpeed);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    generateRandomMaze() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            generatingMaze: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const { grid } = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const walls = randomMaze(grid, startNode, finishNode);\r\n\r\n            this.animateMaze(walls);\r\n\r\n        }, this.state.mazeSpeed);\r\n\r\n    }\r\n\r\n    generateRecursiveDivisionMaze() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            generatingMaze: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const { grid } = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n\r\n            this.animateMaze(walls);\r\n\r\n        }, this.state.mazeSpeed);\r\n\r\n    }\r\n\r\n    generateVerticalMaze() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            generatingMaze: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const { grid } = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const walls = verticalMaze(grid, startNode, finishNode);\r\n\r\n            this.animateMaze(walls);\r\n\r\n        }, this.state.mazeSpeed);\r\n\r\n    }\r\n\r\n    generateHorizontalMaze() {\r\n\r\n        if (this.state.visualizingAlgorithm || this.state.generatingMaze) return;\r\n\r\n        this.setState({\r\n            generatingMaze: true\r\n        });\r\n\r\n        setTimeout(() => {\r\n\r\n            const {grid} = this.state;\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n\r\n            const walls = horizontalMaze(grid, startNode, finishNode);\r\n\r\n            this.animateMaze(walls);\r\n\r\n        }, this.state.mazeSpeed);\r\n\r\n    }\r\n\r\n\r\n    // MAIN RENDER METHOD:\r\n    // Required for components.\r\n\r\n    render() {\r\n\r\n        let {grid} = this.state;\r\n\r\n        return (\r\n\r\n            <React.Fragment>\r\n\r\n                {/* The navigation bar with interaction options. */}\r\n                <NavBar\r\n\r\n                    visualizingAlgorithm={this.state.visualizingAlgorithm}\r\n                    generatingMaze={this.state.generatingMaze}\r\n\r\n                    visualizeDijkstra={this.visualizeDijkstra.bind(this)}\r\n                    visualizeAStar={this.visualizeAStar.bind(this)}\r\n                    visualizeGreedyBFS={this.visualizeGreedyBFS.bind(this)}\r\n                    visualizeBidirectionalGreedySearch={this.visualizeBidirectionalGreedySearch.bind(this)}\r\n                    visualizeBFS={this.visualizeBFS.bind(this)}\r\n                    visualizeDFS={this.visualizeDFS.bind(this)}\r\n                    visualizeRandomWalk={this.visualizeRandomWalk.bind(this)}\r\n\r\n                    generateRandomMaze={this.generateRandomMaze.bind(this)}\r\n                    generateRecursiveDivisionMaze={this.generateRecursiveDivisionMaze.bind(this)}\r\n                    generateVerticalMaze={this.generateVerticalMaze.bind(this)}\r\n                    generateHorizontalMaze={this.generateHorizontalMaze.bind(this)}\r\n\r\n                    clearGrid={this.clearGrid.bind(this)}\r\n                    clearPath={this.clearPath.bind(this)}\r\n                    updateSpeed={this.updateSpeed.bind(this)}\r\n\r\n                    algorithm={this.state.algorithm}\r\n                    updateAlgorithm={this.updateAlgorithm.bind(this)}\r\n\r\n                />\r\n\r\n                {/* Instructions for the grid. */}\r\n                <div className=\"grid-instructions\">\r\n                    <p>\r\n                        <i>Click</i> or <i>drag</i> within the grid to toggle walls.<br />\r\n                        Alternatively, create a maze using the options above.<br />\r\n                        Then, select a pathfinding algorithm and visualize it!\r\n                    </p>\r\n                </div>\r\n\r\n                {/* The key for the grid. */}\r\n                <div className=\"gridKey\">\r\n\r\n                    <div className=\"keyItem\">\r\n                        <div className=\"keyIcon\">\r\n\r\n                        <Node\r\n\r\n                            key=\"key-node-start\"\r\n\r\n                            row={-1}\r\n                            col={-1}\r\n\r\n                            isStart={true}\r\n                            isFinish={false}\r\n                            isVisited={false}\r\n                            isShortest={false}\r\n                            isWall={false}\r\n\r\n                            width={this.state.width * 1.3}\r\n                            height={this.state.height * 1.3}\r\n                            numRows={this.state.numRows}\r\n                            numColumns={this.state.numColumns}\r\n\r\n                        />\r\n                    </div>\r\n                        <div className=\"keyLabel\">Start Node</div>\r\n                    </div>\r\n\r\n                    <div className=\"keyItem\">\r\n                        <div className=\"keyIcon\">\r\n                        <Node\r\n\r\n                            key=\"key-node-finish\"\r\n\r\n                            row={-1}\r\n                            col={-1}\r\n\r\n                            isStart={false}\r\n                            isFinish={true}\r\n                            isVisited={false}\r\n                            isShortest={false}\r\n                            isWall={false}\r\n\r\n                            width={this.state.width * 1.3}\r\n                            height={this.state.height * 1.3}\r\n                            numRows={this.state.numRows}\r\n                            numColumns={this.state.numColumns}\r\n\r\n                        />\r\n                    </div>\r\n                        <div className=\"keyLabel\">Goal Node</div>\r\n                    </div>\r\n\r\n                    <div className=\"keyItem\">\r\n                        <div className=\"keyIcon\">\r\n                        <Node\r\n\r\n                            key=\"key-node-wall\"\r\n\r\n                            row={-1}\r\n                            col={-1}\r\n\r\n                            isStart={false}\r\n                            isFinish={false}\r\n                            isVisited={false}\r\n                            isShortest={false}\r\n                            isWall={true}\r\n\r\n                            width={this.state.width * 1.3}\r\n                            height={this.state.height * 1.3}\r\n                            numRows={this.state.numRows}\r\n                            numColumns={this.state.numColumns}\r\n\r\n                        />\r\n                    </div>\r\n                        <div className=\"keyLabel\">Wall Node</div>\r\n                    </div>\r\n\r\n                </div>\r\n\r\n                {/* The grid. */}\r\n                <div className={this.state.visualizingAlgorithm || this.state.generatingMaze ? \"grid-visualizing\" : \"grid\"}>\r\n\r\n                    {/* Map every row and column (# determined by the screen dimensions) to Node component. */}\r\n                    {grid.map((row, rowId) => {\r\n\r\n                        return (\r\n\r\n                            <div key={rowId}>\r\n\r\n                                {row.map((node, nodeId) => {\r\n\r\n                                    const {\r\n                                        row,\r\n                                        col,\r\n                                        isStart,\r\n                                        isFinish,\r\n                                        isVisited,\r\n                                        isShortest,\r\n                                        isWall,\r\n                                    } = node;\r\n\r\n                                    return (\r\n\r\n                                        <Node\r\n\r\n                                            key={nodeId}\r\n\r\n                                            row={row}\r\n                                            col={col}\r\n\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isVisited={isVisited}\r\n                                            isShortest={isShortest}\r\n                                            isWall={isWall}\r\n\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n\r\n                                            width={this.state.width}\r\n                                            height={this.state.height}\r\n                                            numRows={this.state.numRows}\r\n                                            numColumns={this.state.numColumns}\r\n\r\n                                        ></Node>\r\n                                    );\r\n\r\n                                })}\r\n\r\n                            </div>\r\n                        );\r\n\r\n                    })}\r\n\r\n                </div>\r\n\r\n                {/* Pseudocode for selected algorithm component. */}\r\n                <Pseudocode\r\n                    algorithm={this.state.algorithm}\r\n                    updateAlgorithm={this.updateAlgorithm.bind(this)}\r\n                />\r\n\r\n            </React.Fragment>\r\n\r\n        );\r\n\r\n    }\r\n\r\n\r\n} // MazeSolver{}.\r\n\r\n\r\nfunction getInitDimensions(width, height) {\r\n\r\n    let numCols;\r\n\r\n    if (width > 1500) numCols = Math.floor(width / 25);\r\n    else if (width > 1250) numCols = Math.floor(width / 22.5);\r\n    else if (width > 1000) numCols = Math.floor(width / 20);\r\n    else if (width > 750) numCols = Math.floor(width / 17.5);\r\n    else if (width > 500) numCols = Math.floor(width / 15);\r\n    else if (width > 250) numCols = Math.floor(width / 12.5);\r\n    else if (width > 0) numCols = Math.floor(width / 10);\r\n\r\n    let cellWidth = Math.floor(width / numCols);\r\n\r\n    let numRows = Math.floor(height / cellWidth);\r\n\r\n    return [numRows, numCols];\r\n\r\n}\r\n\r\nfunction getRandomNums(num) {\r\n\r\n    let randomNums1 = [];\r\n    let temp = 2;\r\n    for (let i = 5; i < num / 2; i += 2) {\r\n        randomNums1.push(temp);\r\n        temp += 2;\r\n    }\r\n\r\n    let randomNums2 = [];\r\n    temp = -2;\r\n    for (let i = num / 2; i < num - 5; i += 2) {\r\n        randomNums2.push(temp);\r\n        temp -= 2;\r\n    }\r\n\r\n    return [randomNums1, randomNums2];\r\n\r\n}\r\n\r\nfunction getStartFinishNodes(numRows, numColumns) {\r\n\r\n    let randNums;\r\n\r\n    let x;\r\n    let y;\r\n\r\n    let startNodeRow;\r\n    let startNodeCol;\r\n\r\n    let finishNodeRow;\r\n    let finishNodeCol;\r\n\r\n    if (numRows < numColumns) {\r\n\r\n        randNums = getRandomNums(numRows);\r\n        x = Math.floor(numRows / 2);\r\n        y = Math.floor(numColumns / 4);\r\n\r\n        if (x % 2 !== 0) x -= 1;\r\n        if (y % 2 !== 0) y += 1;\r\n\r\n        startNodeRow = x + randNums[1][Math.floor(Math.random() * randNums[1].length)];\r\n        startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\r\n\r\n        finishNodeRow = x + randNums[0][Math.floor(Math.random() * randNums[0].length)];\r\n        finishNodeCol = numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\r\n\r\n    } else {\r\n\r\n        randNums = getRandomNums(numColumns);\r\n        x = Math.floor(numRows / 4);\r\n        y = Math.floor(numColumns / 2);\r\n\r\n        if (x % 2 !== 0) x -= 1;\r\n        if (y % 2 !== 0) y += 1;\r\n\r\n        startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\r\n        startNodeCol = y + randNums[1][Math.floor(Math.random() * randNums[1].length)];\r\n\r\n        finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\r\n        finishNodeCol = y + randNums[0][Math.floor(Math.random() * randNums[0].length)];\r\n\r\n    }\r\n\r\n    return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\r\n\r\n}\r\n\r\nconst getInitialGrid = (numRows, numColumns) => {\r\n\r\n    let grid = [];\r\n\r\n    for (let row = 0; row < numRows; row++) {\r\n\r\n        let currentRow = [];\r\n        for (let col = 0; col < numColumns; col++) currentRow.push(createNode(row, col));\r\n        grid.push(currentRow);\r\n\r\n    }\r\n\r\n    return grid;\r\n\r\n};\r\n\r\nconst createNode = (row, col) => {\r\n\r\n    return {\r\n\r\n        row,\r\n        col,\r\n\r\n        isStart: row === startNodeRow && col === startNodeCol,\r\n        isFinish: row === finishNodeRow && col === finishNodeCol,\r\n\r\n        distance: Infinity,\r\n        totalDistance: Infinity,\r\n\r\n        isVisited: false,\r\n        isShortest: false,\r\n        isWall: false,\r\n\r\n        previousNode: null,\r\n\r\n    };\r\n\r\n};\r\n\r\nconst getNewGridWithWalls = (grid, row, col) => {\r\n\r\n    let newGrid = grid.slice();\r\n\r\n    let node = grid[row][col];\r\n    let newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n\r\n    return newGrid;\r\n\r\n};\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n\r\n    let newGrid = grid.slice();\r\n\r\n    for (let wall of walls) {\r\n\r\n        let node = grid[wall[0]][wall[1]];\r\n        let newNode = {\r\n            ...node,\r\n            isWall: true,\r\n        };\r\n        newGrid[wall[0]][wall[1]] = newNode;\r\n\r\n    }\r\n\r\n    return newGrid;\r\n\r\n};\r\n\r\nconst getGridWithoutPath = (grid) => {\r\n\r\n    let newGrid = grid.slice();\r\n\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n\r\n            let newNode = {\r\n                ...node,\r\n                distance: Infinity,\r\n                totalDistance: Infinity,\r\n                isVisited: false,\r\n                isShortest: false,\r\n                previousNode: null,\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n\r\n};\r\n\r\nconst updateNodesForRender = (grid, nodesOptimalPathOrdered, nodesVisitedOrdered) => {\r\n\r\n    let newGrid = grid.slice();\r\n\r\n    for (let node of nodesVisitedOrdered) {\r\n\r\n        if ((node.row === startNodeRow && node.col === startNodeCol) ||\r\n            (node.row === finishNodeRow && node.col === finishNodeCol)) continue;\r\n\r\n        let newNode = {\r\n            ...node,\r\n            isVisited: true,\r\n        };\r\n\r\n        newGrid[node.row][node.col] = newNode;\r\n\r\n    }\r\n\r\n    for (let node of nodesOptimalPathOrdered) {\r\n\r\n        if (node.row === finishNodeRow && node.col === finishNodeCol) return newGrid;\r\n\r\n        let newNode = {\r\n            ...node,\r\n            isVisited: false,\r\n            isShortest: true,\r\n        };\r\n\r\n        newGrid[node.row][node.col] = newNode;\r\n    }\r\n\r\n};\r\n\r\nconst getVisitedNodesInOrder = (nodesVisitedOrderedStart, nodesVisitedOrderedFinish) => {\r\n\r\n    let visitedNodesInOrder = [];\r\n\r\n    let n = Math.max(nodesVisitedOrderedStart.length, nodesVisitedOrderedFinish.length);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n\r\n        if (nodesVisitedOrderedStart[i] !== undefined) visitedNodesInOrder.push(nodesVisitedOrderedStart[i]);\r\n\r\n        if (nodesVisitedOrderedFinish[i] !== undefined) visitedNodesInOrder.push(nodesVisitedOrderedFinish[i]);\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n\r\n};\r\n\r\nexport default MazeSolver;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
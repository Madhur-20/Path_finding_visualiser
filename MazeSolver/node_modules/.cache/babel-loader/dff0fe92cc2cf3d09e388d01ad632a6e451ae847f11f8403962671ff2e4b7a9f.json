{"ast":null,"code":"export function greedyBestFS(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let unvisitedNodes = []; // Open list.\n  let visitedNodesInOrder = []; // Closed list.\n\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    let neighbours = getNeighbours(closestNode, grid);\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1;\n\n      // f(n) = h(n).\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction getNeighbours(node, grid) {\n  let neighbours = [];\n  let {\n    row,\n    col\n  } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited);\n}\nfunction manhattenDistance(node, finishNode) {\n  let x = Math.abs(node.row - finishNode.row);\n  let y = Math.abs(node.col - finishNode.col);\n  return x + y;\n}\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function getOptPathNodes_GreedyBestFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["greedyBestFS","grid","startNode","finishNode","unvisitedNodes","visitedNodesInOrder","distance","push","length","sort","a","b","totalDistance","closestNode","shift","isVisited","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","manhattenDistance","previousNode","node","row","col","filter","isWall","x","Math","abs","y","getOptPathNodes_GreedyBestFS","nodesInShortestPathOrder","currentNode"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/search_algorithms/greedyBestFirstSearch.js"],"sourcesContent":["\r\nexport function greedyBestFS(grid, startNode, finishNode) {\r\n\r\n    if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n    let unvisitedNodes = []; // Open list.\r\n    let visitedNodesInOrder = []; // Closed list.\r\n\r\n    startNode.distance = 0;\r\n    unvisitedNodes.push(startNode);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n\r\n        unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        let neighbours = getNeighbours(closestNode, grid);\r\n\r\n        for (let neighbour of neighbours) {\r\n\r\n            let distance = closestNode.distance + 1;\r\n\r\n            // f(n) = h(n).\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n\r\n                unvisitedNodes.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.previousNode = closestNode;\r\n\r\n            } else if (distance < neighbour.distance) {\r\n\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.previousNode = closestNode;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n\r\n    return neighbours.filter((neighbour) => !neighbour.isWall && !neighbour.isVisited);\r\n\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n\r\n    let x = Math.abs(node.row - finishNode.row);\r\n    let y = Math.abs(node.col - finishNode.col);\r\n    return x + y;\r\n\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n\r\n    for (let node of unvisitedNodes) {\r\n        if (node.row === neighbour.row && node.col === neighbour.col) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n\r\n}\r\n\r\nexport function getOptPathNodes_GreedyBestFS(finishNode) {\r\n\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPathOrder;\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) return;\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) addWall(num, vertical, startNode, finishNode);\n    if (choice === 1 && num % 2 === 0) addWall(num, vertical, startNode, finishNode);\n  }\n}\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","map":{"version":3,"names":["walls","horizontalMaze","grid","startNode","finishNode","vertical","range","length","horizontal","getHorizontalWalls","len","result","i","push","choice","Math","floor","random","num","addWall","isStartFinish","tempWalls","temp","row","col","splice","wall"],"sources":["C:/Users/HP/Desktop/PathFinding Visualiser/MazeSolver/src/maze_algorithms/horizontalMaze.js"],"sourcesContent":["let walls;\r\n\r\nexport function horizontalMaze(grid, startNode, finishNode) {\r\n\r\n  if (!startNode || !finishNode || startNode === finishNode) return false;\r\n\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n\r\n  walls = [];\r\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\r\n\r\n  return walls;\r\n\r\n}\r\n\r\nfunction range(len) {\r\n\r\n  let result = [];\r\n\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n\r\n  return result;\r\n\r\n}\r\n\r\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\r\n\r\n  if (horizontal.length < 2) return;\r\n\r\n  let choice = Math.floor(Math.random() * 2);\r\n\r\n  for (let num of horizontal) {\r\n\r\n    if (choice === 0 && num % 2 !== 0) addWall(num, vertical, startNode, finishNode);\r\n\r\n    if (choice === 1 && num % 2 === 0) addWall(num, vertical, startNode, finishNode);\r\n\r\n  }\r\n\r\n}\r\n\r\nfunction addWall(num, vertical, startNode, finishNode) {\r\n\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n\r\n  for (let temp of vertical) {\r\n\r\n    if ((num === startNode.row && temp === startNode.col) ||\r\n        (num === finishNode.row && temp === finishNode.col)) {\r\n\r\n      isStartFinish = true;\r\n      continue;\r\n\r\n    }\r\n\r\n    tempWalls.push([num, temp]);\r\n\r\n  }\r\n\r\n  if (!isStartFinish) tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n\r\n}"],"mappings":"AAAA,IAAIA,KAAK;AAET,OAAO,SAASC,cAAcA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAE1D,IAAI,CAACD,SAAS,IAAI,CAACC,UAAU,IAAID,SAAS,KAAKC,UAAU,EAAE,OAAO,KAAK;EAEvE,IAAIC,QAAQ,GAAGC,KAAK,CAACJ,IAAI,CAAC,CAAC,CAAC,CAACK,MAAM,CAAC;EACpC,IAAIC,UAAU,GAAGF,KAAK,CAACJ,IAAI,CAACK,MAAM,CAAC;EAEnCP,KAAK,GAAG,EAAE;EACVS,kBAAkB,CAACJ,QAAQ,EAAEG,UAAU,EAAEL,SAAS,EAAEC,UAAU,CAAC;EAE/D,OAAOJ,KAAK;AAEd;AAEA,SAASM,KAAKA,CAACI,GAAG,EAAE;EAElB,IAAIC,MAAM,GAAG,EAAE;EAEf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAC5BD,MAAM,CAACE,IAAI,CAACD,CAAC,CAAC;EAChB;EAEA,OAAOD,MAAM;AAEf;AAEA,SAASF,kBAAkBA,CAACJ,QAAQ,EAAEG,UAAU,EAAEL,SAAS,EAAEC,UAAU,EAAE;EAEvE,IAAII,UAAU,CAACD,MAAM,GAAG,CAAC,EAAE;EAE3B,IAAIO,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;EAE1C,KAAK,IAAIC,GAAG,IAAIV,UAAU,EAAE;IAE1B,IAAIM,MAAM,KAAK,CAAC,IAAII,GAAG,GAAG,CAAC,KAAK,CAAC,EAAEC,OAAO,CAACD,GAAG,EAAEb,QAAQ,EAAEF,SAAS,EAAEC,UAAU,CAAC;IAEhF,IAAIU,MAAM,KAAK,CAAC,IAAII,GAAG,GAAG,CAAC,KAAK,CAAC,EAAEC,OAAO,CAACD,GAAG,EAAEb,QAAQ,EAAEF,SAAS,EAAEC,UAAU,CAAC;EAElF;AAEF;AAEA,SAASe,OAAOA,CAACD,GAAG,EAAEb,QAAQ,EAAEF,SAAS,EAAEC,UAAU,EAAE;EAErD,IAAIgB,aAAa,GAAG,KAAK;EACzB,IAAIC,SAAS,GAAG,EAAE;EAElB,KAAK,IAAIC,IAAI,IAAIjB,QAAQ,EAAE;IAEzB,IAAKa,GAAG,KAAKf,SAAS,CAACoB,GAAG,IAAID,IAAI,KAAKnB,SAAS,CAACqB,GAAG,IAC/CN,GAAG,KAAKd,UAAU,CAACmB,GAAG,IAAID,IAAI,KAAKlB,UAAU,CAACoB,GAAI,EAAE;MAEvDJ,aAAa,GAAG,IAAI;MACpB;IAEF;IAEAC,SAAS,CAACR,IAAI,CAAC,CAACK,GAAG,EAAEI,IAAI,CAAC,CAAC;EAE7B;EAEA,IAAI,CAACF,aAAa,EAAEC,SAAS,CAACI,MAAM,CAACV,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGI,SAAS,CAACd,MAAM,CAAC,EAAE,CAAC,CAAC;EAErF,KAAK,IAAImB,IAAI,IAAIL,SAAS,EAAE;IAC1BrB,KAAK,CAACa,IAAI,CAACa,IAAI,CAAC;EAClB;AAEF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}